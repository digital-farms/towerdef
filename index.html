<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Tower Defense Clean</title>
  <style>
    body { margin: 0; background: #000; }
    canvas { display: block; margin: auto; background: #111; }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div style="width:640px;margin:10px auto 0 auto;display:flex;justify-content:center;align-items:center;gap:16px;">
  <button id="startRunBtn" style="font-size:18px; padding:6px 12px;">Start</button>
  <button id="spawnPlus" style="font-size:24px;">+</button>
  <span id="spawnRateDisplay" style="font-size:18px;color:white;font-family:sans-serif;text-shadow:0 0 2px #000;">0.01</span>
</div>
<span id="spawnRateCorner" style="position:fixed;top:8px;left:8px;font-size:13px;color:#fff;background:rgba(0,0,0,0.5);padding:2px 7px;border-radius:7px;font-family:sans-serif;z-index:10;pointer-events:none;">rate: 0.01</span>
<audio id="spawnTowerSound" src="sound/spawnTower.mp3" preload="auto"></audio>
<audio id="basicTowerShotSound" src="sound/laserShot_basicTower.mp3" preload="auto"></audio>
<audio id="golemSpawnSound" src="sound/Monster_Roar7.mp3" preload="auto"></audio>
<script src="leaderboard.js"></script>
<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- НАСТРОЙКИ ГРОМКОСТИ ЗВУКОВ ---
// Диапазон значений: 0.0 (тихо) — 1.0 (макс)
const SPAWN_TOWER_VOL = 0.6;      // громкость звука появления башни
const BASIC_SHOT_VOL = 0.13;      // громкость выстрела обычной башни
const GOLEM_SPAWN_VOL = 0.3;      // громкость рыка при спавне голема

// Images
const bgImage = new Image();
bgImage.src = './map.png';

const dinoSprite = new Image();
dinoSprite.src = './dino_sprite.png';

const baseImg = new Image();
baseImg.src = './base.png';

const turretImg = new Image();
turretImg.src = './turret.png';

const golemSprite = new Image();
golemSprite.src = './Golem_1_walk.png';

// Спрайт смерти голема (10 кадров, спрайт-лист 900x40)
const golemDieSprite = new Image();
golemDieSprite.src = './Golem_1_die_1.png';

// Спрайт взрыва для базового моба (10 кадров по горизонтали, 352x32)
const explosionBasicMobSprite = new Image();
explosionBasicMobSprite.src = './explosion_basicMob_2.png';
// Коэффициент масштабирования взрыва ("немного больше")
const EXPLOSION_BASIC_SCALE = 1.5;

// Спрайт башни за подарок 1 уровня
const giftL1Img = new Image();
giftL1Img.src = 'gift_towers_assets/1lvl_gift_tower.png';
// Спрайт башни за подарок 2 уровня
const giftL2Img = new Image();
giftL2Img.src = 'gift_towers_assets/2lvl_gift_tower.png';

// Game state
const towers = [];
const enemies = [];
const bullets = [];
const base = { x: 540, y: 80, hp: 10000 };

const path = [
  { x: 0,   y: 260 },
  { x: 105, y: 260 },
  { x: 105, y: 120 },
  { x: 235, y: 120 },
  { x: 235, y: 310 },
  { x: 405, y: 310 },
  { x: 405, y: 210 },
  { x: 520, y: 210 }
];

let enemySpawnRate = 0.004; // ниже стартовая частота спавна
// Коэффициент плотности обычных мобов: <1 — реже спавн; баланс сохраняем повышением HP и урона
const ENEMY_DENSITY_SCALE = 0.33; // ~в 3 раза меньше мобов
// Базовые параметры обычного моба до масштабирования
const BASE_ENEMY_HP = 3;
const BASE_ENEMY_BASE_DAMAGE = 1;
// Производные параметры под масштаб
const ENEMY_SCALED_HP = Math.max(1, Math.round(BASE_ENEMY_HP / ENEMY_DENSITY_SCALE));
const ENEMY_SCALED_BASE_DAMAGE = Math.max(1, Math.round(BASE_ENEMY_BASE_DAMAGE / ENEMY_DENSITY_SCALE));

// --- РЕЖИМ РЕСТАРТА ПО ЛАЙКАМ / РУЧНОЙ СТАРТ ---
// Флаг использования рестарта по лайкам. Если false — можно запускать забег вручную кнопкой "Start"
const USE_LIKES_RESTART = true; // переключите на false, чтобы отключить механику лайков
// Порог лайков для старта/рестарта (редактируйте при необходимости)
let RESTART_LIKES_TARGET = 10;
// Состояние игры: 'running' | 'waitingRestart'
let gameState = USE_LIKES_RESTART ? 'waitingRestart' : 'running';
// Счётчик лайков в текущем окне ожидания
let restartLikesAccum = 0;
// Отслеживание лайков по пользователям, чтобы считать дельты независимо от серверного режима
const lastSeenLikesByUser = Object.create(null);

// Возможность отключать экран рестарта (оверлей)
let SHOW_RESTART_OVERLAY = true; // переключайте на false, чтобы скрыть оверлей ожидания
// Быстрый переключатель из консоли: setShowRestartOverlay(true/false)
window.setShowRestartOverlay = function(v) { SHOW_RESTART_OVERLAY = !!v; };

// Кнопка запуска забега вручную
const startRunBtn = document.getElementById('startRunBtn');
function updateUIButtons() {
  if (!startRunBtn) return;
  startRunBtn.style.display = (gameState === 'running') ? 'none' : 'inline-block';
}
if (startRunBtn) {
  startRunBtn.onclick = () => {
    startGameRun();
    updateUIButtons();
  };
}
// Первичная синхронизация видимости кнопки после определения gameState
updateUIButtons();

// --- Зоны для спавна башен зрителей (по картинке) ---
const ALLOWED_TOWER_ZONES = [
  // [x1, y1, x2, y2] — координаты прямоугольников (всегда в "игровых" координатах 0..640, 0..480)
  [12, 140, 500, 380],      // Левый верхний
  // другие зоны не используются
];
let showTowerZones = false; // Показывать красные зоны (можно убрать потом)

// --- Запрет спавна башен на дороге у мобов ---
// Радиус запрета размещения башен около пути (в игровых пикселях 640x480)
const PATH_FORBIDDEN_RADIUS = 24;

// Расстояние от точки до отрезка
function distancePointToSegment(px, py, x1, y1, x2, y2) {
  const vx = x2 - x1, vy = y2 - y1;
  const wx = px - x1, wy = py - y1;
  const c1 = vx * wx + vy * wy;
  if (c1 <= 0) return Math.hypot(px - x1, py - y1);
  const c2 = vx * vx + vy * vy;
  if (c2 <= c1) return Math.hypot(px - x2, py - y2);
  const b = c1 / c2;
  const bx = x1 + b * vx, by = y1 + b * vy;
  return Math.hypot(px - bx, py - by);
}

// Проверка: точка близко к любому сегменту пути
function isNearPath(x, y, threshold = PATH_FORBIDDEN_RADIUS) {
  for (let i = 0; i < path.length - 1; i++) {
    const a = path[i], b = path[i + 1];
    const d = distancePointToSegment(x, y, a.x, a.y, b.x, b.y);
    if (d < threshold) return true;
  }
  return false;
}

// --- Геометрия для определения слоя отрисовки относительно дороги ---
// Ближайшая точка на сегменте AB к P(px,py)
function closestPointOnSegment(px, py, x1, y1, x2, y2) {
  const vx = x2 - x1, vy = y2 - y1;
  const wx = px - x1, wy = py - y1;
  const c2 = vx * vx + vy * vy;
  if (c2 <= 1e-6) return { x: x1, y: y1, t: 0 };
  let t = (vx * wx + vy * wy) / c2;
  t = Math.max(0, Math.min(1, t));
  return { x: x1 + t * vx, y: y1 + t * vy, t };
}

// Возвращает Y ближайшей точки пути к (x,y)
function getClosestPathY(x, y) {
  let best = null;
  for (let i = 0; i < path.length - 1; i++) {
    const a = path[i], b = path[i + 1];
    const p = closestPointOnSegment(x, y, a.x, a.y, b.x, b.y);
    const dx = p.x - x, dy = p.y - y;
    const dist2 = dx * dx + dy * dy;
    if (!best || dist2 < best.dist2) best = { y: p.y, dist2 };
  }
  return best ? best.y : null;
}

// Возвращает "земельную" Y башни для сравнения с дорогой
function getTowerGroundY(t) {
  // Для подарочной башни учитываем смещение основания
  if (t instanceof GiftAvatarTower) {
    const cfg = GIFT_TOWER_LEVELS[t.level] || GIFT_TOWER_LEVELS[1];
    return t.y + (cfg && cfg.baseYOffset ? cfg.baseYOffset : 0);
  }
  // Обычные башни и аватар-башни — используем их Y как базу
  return t.y;
}

// Небольшой порог, чтобы избежать мигания на границе дороги
const FRONT_Y_EPS = 4;

// Поиск валидной позиции внутри разрешённых зон, вдали от пути
function findValidSpawnPos() {
  const zone = ALLOWED_TOWER_ZONES[0];
  const [x1, y1, x2, y2] = zone;
  const w = x2 - x1, h = y2 - y1;
  const radius = 16;
  if (w < radius * 2 || h < radius * 2) {
    return { x: x1 + w / 2, y: y1 + h / 2 };
  }
  for (let attempts = 0; attempts < 60; attempts++) {
    const x = x1 + radius + Math.random() * (w - radius * 2);
    const y = y1 + radius + Math.random() * (h - radius * 2);
    if (!isNearPath(x, y)) return { x, y };
  }
  // fallback: вернём центр зоны, даже если рядом с путём
  return { x: x1 + w / 2, y: y1 + h / 2 };
}

// Характеристики подарочных башен по уровням (боевые и визуальные)
const GIFT_TOWER_LEVELS = {
  1: {
    // Боевые
    shotsLeft: 150,
    fireRate: 45,
    range: 100,
    // Визуальные
    tw: 45,              // ширина спрайта на сцене
    th: 65,              // высота спрайта на сцене
    baseYOffset: 24,     // сдвиг башни по Y (основание)
    killTextYOffset: 20, // сдвиг текста киллов относительно верха спрайта
    avatarYOffset: 32,   // сдвиг центра аватарки относительно верха спрайта
    avatarRadius: 15,    // радиус круга аватарки
    avatarStroke: 6,     // толщина обводки круга
    avatarStrokeColor: '#0000ff' // цвет обводки круга
  },
  2: {
    // Боевые
    shotsLeft: 250,
    fireRate: 30,
    range: 120,
    // Визуальные (пока такие же как у L1 — можно менять отдельно)
    tw: 45,
    th: 65,
    baseYOffset: 30,
    killTextYOffset: 20,
    avatarYOffset: 32,
    avatarRadius: 15,
    avatarStroke: 6,
    avatarStrokeColor: '#FF0000' // цвет обводки круга для L2
  }
};

// Цвет пули для подарочной башни по уровню (совпадает с цветом обводки аватарки)
function getGiftTowerBulletColor(level) {
  const cfg = GIFT_TOWER_LEVELS[level] || GIFT_TOWER_LEVELS[1];
  return cfg && cfg.avatarStrokeColor ? cfg.avatarStrokeColor : 'yellow';
}

function randomTowerPositionInAllowedZones() {
  const zone = ALLOWED_TOWER_ZONES[0];
  let [x1, y1, x2, y2] = zone;
  const w = x2 - x1;
  const h = y2 - y1;
  const radius = 16;
  if (w < radius * 2 || h < radius * 2) {
    const pos = { x: x1 + w / 2, y: y1 + h / 2 };
    console.warn('[TOWER_SPAWN_DEBUG] маленькая зона', pos, 'zone:', [x1, y1, x2, y2]);
    return pos;
  }
  // Выбираем позицию вдали от пути
  const pos = findValidSpawnPos();
  console.warn('[TOWER_SPAWN_DEBUG] выпало', pos, 'zone:', [x1, y1, x2, y2]);
  return pos;
}

class Enemy {
  constructor() {
    this.x = path[0].x;
    this.y = path[0].y;
    this.pathIndex = 0;
    this.speed = 1;
    this.hp = ENEMY_SCALED_HP;
    this.dead = false;

    // Animation
    this.frame = 0;
    this.frameDelay = 5;
    this.frameCounter = 0;
    this.frameWidth = 80;
    this.frameHeight = 80;

    // Death (explosion) animation
    this.dying = false;
    this.dieFrame = 0;
    this.dieFrameDelay = 3; // быстрее, чем у голема
    this.dieFrameCounter = 0;
    this.dieFramesTotal = 11; // теперь 11 кадров
  }

  update() {
    // Если идёт анимация смерти — проигрываем и выходим
    if (this.dying) {
      this.dieFrameCounter++;
      if (this.dieFrameCounter >= this.dieFrameDelay) {
        this.dieFrameCounter = 0;
        this.dieFrame++;
        if (this.dieFrame >= this.dieFramesTotal) {
          this.dead = true;
        }
      }
      return;
    }
    // Animate
    this.frameCounter++;
    if (this.frameCounter >= this.frameDelay) {
      this.frame = (this.frame + 1) % 8;
      this.frameCounter = 0;
    }

    // Move
    const target = path[this.pathIndex + 1];
    if (!target) {
      base.hp -= ENEMY_SCALED_BASE_DAMAGE;
      this.dead = true;
      return;
    }
    const dx = target.x - this.x;
    const dy = target.y - this.y;
    const dist = Math.hypot(dx, dy);
    if (dist < this.speed) {
      this.pathIndex++;
    } else {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    }
  }

  draw() {
    // Если умирает — рисуем взрыв меньшего размера
    if (this.dying) {
      if (explosionBasicMobSprite.complete && explosionBasicMobSprite.width > 0) {
        const fw = explosionBasicMobSprite.width / 11; // 11 кадров по горизонтали
        const fh = explosionBasicMobSprite.height;
        const sx = Math.min(this.dieFrame, 10) * fw;
        const sy = 0;
        // Центруем по нижнему центру моба (как сам моб), чуть выше земли
        const drawW = fw * EXPLOSION_BASIC_SCALE; // масштабируем немного больше
        const drawH = fh * EXPLOSION_BASIC_SCALE;
        ctx.drawImage(
          explosionBasicMobSprite,
          sx, sy, fw, fh,
          this.x - drawW / 2, this.y - drawH, // нижний центр
          drawW, drawH
        );
      }
      return;
    }
    // Для всех мобов: якорь по центру НИЗА (ноги идут по линии пути)
    // Спрайт 60x60: смещаем по x на -30, по y на -60 (нижний центр)
    ctx.drawImage(
      dinoSprite,
      this.frame * this.frameWidth, 0,
      this.frameWidth, this.frameHeight,
      this.x - 30, this.y - 60, // x - w/2, y - h (центр по низу)
      60, 60
    );
  }

  startDying() {
    if (this.dying) return;
    this.dying = true;
    this.dieFrame = 0;
    this.dieFrameCounter = 0;
  }
}

class Tower {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.range = 100;
    this.fireRate = 45;
    this.cooldown = 0;
    this.killCount = 0;
    this.shotsLeft = 50; // Лимит выстрелов
    // Для редкого звука выстрела
    this.shotCounter = 0;
    this.shotSoundEveryN = 3; // играть звук каждого N-го выстрела
    this.dead = false;   // Флаг удаления
  }

  update() {
    if (this.cooldown > 0) {
      this.cooldown--;
      return;
    }
    if (this.shotsLeft <= 0) {
      this.dead = true;
      return;
    }
    for (const e of enemies) {
      const dx = e.x - this.x;
      const dy = e.y - this.y;
      if (Math.hypot(dx, dy) <= this.range) {
        bullets.push(new Bullet(this.x, this.y, e, this));
        this.cooldown = this.fireRate;
        this.shotsLeft--;
        // Редко проигрываем звук выстрела, чтобы не спамить
        this.shotCounter = (this.shotCounter + 1) % this.shotSoundEveryN;
        if (this.shotCounter === 0) {
          playBasicTowerShotSound();
        }
        break;
      }
    }
  }

  draw() {
    ctx.drawImage(
      turretImg,
      this.x - 26, this.y - 26,
      52, 52
    );
    // Рисуем killCount над башней
    ctx.save();
    ctx.font = 'bold 16px Arial';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.textAlign = 'center';
    ctx.strokeText(this.killCount, this.x, this.y - 34);
    ctx.fillText(this.killCount, this.x, this.y - 34);
    ctx.restore();
    // Показываем оставшиеся выстрелы мелко под башней
    ctx.save();
    ctx.font = '10px Arial';
    ctx.fillStyle = '#aaa';
    ctx.textAlign = 'center';
    ctx.fillText(this.shotsLeft, this.x, this.y + 28);
    ctx.restore();
  }
}

class AvatarTower extends Tower {
  constructor(x, y, avatarImg, nickname, userId) {
    super(x, y);
    this.avatarImg = avatarImg;
    this.nickname = nickname || userId || 'anon';
    this.userId = userId || null;
    console.warn('[AVATAR_CONSTRUCTOR_DEBUG]', x, y, this.nickname, this.userId);
  }
  draw() {
    if (this.avatarImg && this.avatarImg.complete) {
      ctx.save();
      // Обводка — круг
      ctx.beginPath();
      ctx.arc(this.x, this.y, 15, 0, Math.PI * 2);
      ctx.lineWidth = 6;
      ctx.strokeStyle = '#222';
      ctx.stroke();
      ctx.clip();
      ctx.drawImage(this.avatarImg, this.x - 26, this.y - 26, 52, 52);
      ctx.restore();
    } else {
      super.draw();
      return;
    }
    // Рисуем killCount над башней
    ctx.save();
    ctx.font = 'bold 15px Arial';
    ctx.fillStyle = 'white';
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 2;
    ctx.textAlign = 'center';
    ctx.strokeText(this.killCount, this.x, this.y - 12);
    ctx.fillText(this.killCount, this.x, this.y - 12);
    ctx.restore();
    // Показываем оставшиеся выстрелы мелко под башней
    ctx.save();
    ctx.font = '10px Arial';
    ctx.fillStyle = '#aaa';
    ctx.textAlign = 'center';
    ctx.fillText(this.shotsLeft, this.x, this.y + 24);
    ctx.restore();
  }
}

// Подарочная башня 1 уровня с аватаркой поверх
class GiftAvatarTower extends Tower {
  constructor(x, y, avatarImg = null, nickname = null, userId = null, level = 1) {
    super(x, y);
    this.avatarImg = avatarImg;
    this.nickname = nickname || userId || 'anon';
    this.userId = userId || null;
    // Характеристики по уровню
    this.level = Number(level) || 1;
    const cfg = GIFT_TOWER_LEVELS[this.level] || GIFT_TOWER_LEVELS[1];
    this.shotsLeft = cfg.shotsLeft;
    this.fireRate  = cfg.fireRate;
    this.range     = cfg.range;
  }
  draw() {
    // Конфиг уровня (визуальные параметры)
    const cfg = GIFT_TOWER_LEVELS[this.level] || GIFT_TOWER_LEVELS[1];
    const tw = cfg.tw, th = cfg.th;
    const baseYOffset = cfg.baseYOffset;
    const towerImg = (this.level === 2) ? giftL2Img : giftL1Img;
    if (towerImg && towerImg.complete) {
      ctx.drawImage(towerImg, this.x - tw/2, this.y - th + baseYOffset, tw, th);
    } else {
      // Плейсхолдер пока не загрузился спрайт, чтобы было видно башню
      ctx.save();
      ctx.fillStyle = 'rgba(0,0,255,0.6)';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.fillRect(this.x - tw/2, this.y - th + baseYOffset, tw, th);
      ctx.strokeRect(this.x - tw/2, this.y - th + baseYOffset, tw, th);
      ctx.restore();
    }

    // Далее рисуем аватарку в кружке над башней, если есть
    // ВАЖНО: аватар рисуем до текста killCount, чтобы текст был поверх
    // Рисуем аватарку в кружке над башней, если есть
    if (this.avatarImg && this.avatarImg.complete) {
      const ax = this.x;
      const ay = this.y - th + cfg.avatarYOffset; // позиция центра аватарки
      const R = cfg.avatarRadius;
      const P = 1;  // отступ от обводки
      const IW = 2 * (R - P);
      ctx.save();
      ctx.beginPath();
      ctx.arc(ax, ay, R, 0, Math.PI * 2);
      ctx.lineWidth = cfg.avatarStroke;
      ctx.strokeStyle = cfg.avatarStrokeColor || '#0000ff';
      ctx.stroke();
      ctx.clip();
      ctx.drawImage(this.avatarImg, ax - IW/2, ay - IW/2, IW, IW);
      ctx.restore();
    }

    // Рисуем счётчик киллов поверх аватарки и спрайта
    ctx.save();
    ctx.font = 'bold 15px Arial';
    ctx.lineWidth = 4;
    ctx.strokeStyle = 'black';
    ctx.fillStyle = 'white';
    ctx.textAlign = 'center';
    const killY = this.y - th + cfg.killTextYOffset;
    ctx.strokeText(this.killCount || 0, this.x, killY);
    ctx.fillText(this.killCount || 0, this.x, killY);
    ctx.restore();

    // Показываем оставшиеся выстрелы мелко под башней
    ctx.save();
    ctx.font = '10px Arial';
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.fillText(this.shotsLeft, this.x, this.y + 1);
    ctx.restore();
  }
}

class Bullet {
  constructor(x, y, target, ownerTower = null) {
    this.x = x;
    this.y = y;
    this.target = target;
    this.ownerTower = ownerTower; // Ссылка на башню
    this.speed = 4;
    this.dead = false;
  }

  update() {
    const dx = this.target.x - this.x;
    const dy = this.target.y - this.y;
    const dist = Math.hypot(dx, dy);
    if (dist < this.speed || this.target.hp <= 0) {
      if (this.target.hp > 0) {
        this.target.hp--;
        if (this.target.hp <= 0 && this.ownerTower) {
          this.ownerTower.killCount++;
          updateLeaderboardFromTowers();
        }
      }
      // При нулевом HP — запускаем анимацию смерти (для всех типов врагов)
      if (this.target.hp <= 0) {
        if (typeof this.target.startDying === 'function') {
          this.target.startDying();
        } else {
          this.target.dead = true;
        }
      }
      this.dead = true;
    } else {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    }
  }

  draw() {
    // Цвет пули: для подарочных башен берём цвет обводки аватарки (по уровню)
    if (this.ownerTower instanceof GiftAvatarTower) {
      ctx.fillStyle = getGiftTowerBulletColor(this.ownerTower.level);
    } else {
      ctx.fillStyle = 'black';
    }
    ctx.beginPath();
    ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
    ctx.fill();
  }
}

class GolemBullet {
  constructor(x, y, target) {
    this.x = x;
    this.y = y;
    this.target = target;
    this.speed = 5;
    this.dead = false;
  }
  update() {
    if (!this.target || this.target.dead) {
      this.dead = true;
      return;
    }
    const dx = this.target.x - this.x;
    const dy = this.target.y - this.y;
    const dist = Math.hypot(dx, dy);
    if (dist < this.speed) {
      // Попадание
      if (this.target.killCount !== undefined) {
        this.target.killCount = Math.max(0, this.target.killCount - 3);
      }
      this.dead = true;
      return;
    }
    this.x += (dx / dist) * this.speed;
    this.y += (dy / dist) * this.speed;
  }
  draw() {
    ctx.save();
    ctx.fillStyle = 'yellow';
    ctx.beginPath();
    ctx.arc(this.x, this.y, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }
}

class GolemEnemy extends Enemy {
  constructor() {
    super();
    this.hp = 20;
    this.maxHp = 20;
    this.speed = 0.4;
    this.bulletCooldown = 0;
    this.fireRate = 90; // раз в 1.5 сек
    this.frame = 0;
    this.frameDelay = 6;
    this.frameCounter = 0;
    this.frameWidth = 90;
    this.frameHeight = 52; // было 40, теперь +12
    this.sizeOffsetY = 26; // для центровки
    this.visualScale = 1.4; // Увеличиваем голема на 40%

    // Анимация смерти
    this.dying = false;
    this.dieFrame = 0;
    this.dieFrameDelay = 5; // скорость проигрывания смерти
    this.dieFrameCounter = 0;
    this.dieFrameWidth = 90;
    this.dieFrameHeight = 40;
    this.dieFramesTotal = 10; // 900/90
  }

  update() {
    // Если идёт анимация смерти — проигрываем и выходим
    if (this.dying) {
      this.dieFrameCounter++;
      if (this.dieFrameCounter >= this.dieFrameDelay) {
        this.dieFrameCounter = 0;
        this.dieFrame++;
        if (this.dieFrame >= this.dieFramesTotal) {
          this.dead = true; // удаляем врага после завершения анимации
        }
      }
      return;
    }
    // смерть при 0 HP — старт анимации
    if (this.hp <= 0) {
      this.startDying();
      return;
    }
    const target = path[this.pathIndex + 1];
    if (!target) {
      this.onReachBase();
      return;
    }
    const dx = target.x - this.x;
    const dy = target.y - this.y;
    const dist = Math.hypot(dx, dy);
    if (dist < this.speed) {
      this.pathIndex++;
    } else {
      this.x += (dx / dist) * this.speed;
      this.y += (dy / dist) * this.speed;
    }
    // Стрельба по башням (шариками)
    if (this.bulletCooldown > 0) this.bulletCooldown--;
    else {
      const t = this.findNearestTower();
      if (t) {
        this.shootAt(t);
        this.bulletCooldown = this.fireRate;
      }
    }
    this.frameCounter++;
    if (this.frameCounter >= this.frameDelay) {
      this.frame = (this.frame + 1) % 10;
      this.frameCounter = 0;
    }
  }

  startDying() {
    if (this.dying) return;
    this.dying = true;
    this.dieFrame = 0;
    this.dieFrameCounter = 0;
  }

  findNearestTower() {
    let minDist = 9999, nearest = null;
    for (const t of towers) {
      if (t.dead) continue;
      const dx = t.x - this.x, dy = t.y - this.y;
      const dist = Math.hypot(dx, dy);
      if (dist < minDist) {
        minDist = dist;
        nearest = t;
      }
    }
    return nearest;
  }

  shootAt(tower) {
    bullets.push(new GolemBullet(this.x, this.y, tower));
  }

  onReachBase() {
    base.hp -= 50;
    this.dead = true;
  }

  draw() {
    const scale = this.visualScale;
    if (this.dying) {
      // Рисуем анимацию смерти; якорим по нижнему центру как и ходьбу
      const sx = this.dieFrame * this.dieFrameWidth;
      const sy = 0;
      const dw = this.dieFrameWidth * scale;
      const dh = this.dieFrameHeight * scale;
      ctx.drawImage(
        golemDieSprite,
        sx, sy,
        this.dieFrameWidth, this.dieFrameHeight,
        this.x - (this.dieFrameWidth/2) * scale, this.y - this.sizeOffsetY * scale,
        dw, dh
      );
      return;
    }
    // Обычная анимация ходьбы + HP bar
    ctx.drawImage(
      golemSprite,
      this.frame * this.frameWidth, 0,
      this.frameWidth, this.frameHeight,
      this.x - 45 * scale, this.y - this.sizeOffsetY * scale,
      this.frameWidth * scale, this.frameHeight * scale
    );
    // HP bar
    ctx.fillStyle = '#222';
    ctx.fillRect(this.x - 20 * scale, this.y - this.sizeOffsetY * scale - 8, 40 * scale, 8);
    ctx.fillStyle = '#0f0';
    ctx.fillRect(this.x - 20 * scale, this.y - this.sizeOffsetY * scale - 8, 40 * scale * (this.hp / this.maxHp), 8);
    ctx.strokeStyle = '#000';
    ctx.strokeRect(this.x - 20 * scale, this.y - this.sizeOffsetY * scale - 8, 40 * scale, 8);
  }
}

function drawBase() {
  ctx.drawImage(baseImg, base.x - 64, base.y - 64, 256, 256);
  ctx.save();
  ctx.font = 'bold 20px Arial';
  ctx.lineWidth = 5;
  ctx.strokeStyle = 'black';
  ctx.fillStyle = 'white';
  ctx.textAlign = 'center';
  ctx.strokeText('HP: ' + base.hp, base.x, base.y + 50);
  ctx.fillText('HP: ' + base.hp, base.x, base.y + 50);
  ctx.restore();
}

function resizeCanvas() {
  const aspect = 640 / 480;
  let w = window.innerWidth;
  let h = window.innerHeight;
  if (w / h > aspect) {
    w = h * aspect;
  } else {
    h = w / aspect;
  }
  canvas.width = w;
  canvas.height = h;
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function drawGameOverOverlay() {
  // затемняющий слой
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.fillStyle = 'rgba(0,0,0,0.6)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  // текст
  ctx.font = 'bold 64px Arial';
  ctx.lineWidth = 10;
  ctx.strokeStyle = 'black';
  ctx.fillStyle = '#ff4444';
  ctx.textAlign = 'center';
  ctx.strokeText('GAME OVER', canvas.width/2, canvas.height/2 - 20);
  ctx.fillText('GAME OVER', canvas.width/2, canvas.height/2 - 20);

  // строка "NNN❤️ before RESTART!"
  const remaining = Math.max(0, RESTART_LIKES_TARGET - restartLikesAccum);
  ctx.font = 'bold 36px Arial';
  const text = `${remaining}\u2764\ufe0f before RESTART!`;
  ctx.lineWidth = 6;
  ctx.strokeStyle = 'black';
  ctx.fillStyle = '#ffffff';
  ctx.strokeText(text, canvas.width/2, canvas.height/2 + 40);
  ctx.fillText(text, canvas.width/2, canvas.height/2 + 40);

  // прогресс-бар
  const barW = Math.min(600, canvas.width * 0.8);
  const barH = 20;
  const barX = (canvas.width - barW) / 2;
  const barY = canvas.height/2 + 70;
  const p = Math.min(1, restartLikesAccum / RESTART_LIKES_TARGET);
  ctx.fillStyle = 'rgba(255,255,255,0.2)';
  ctx.fillRect(barX, barY, barW, barH);
  ctx.fillStyle = '#ff2e88';
  ctx.fillRect(barX, barY, barW * p, barH);
  ctx.strokeStyle = '#000';
  ctx.lineWidth = 2;
  ctx.strokeRect(barX, barY, barW, barH);
  ctx.restore();
}

function softResetToWaiting() {
  // Останавливаем бой: чистим сущности и фиксируем спавн
  enemies.length = 0;
  bullets.length = 0;
  towers.length = 0;
  enemySpawnRate = 0.004; // сброс к новому стартовому значению
  updateSpawnRateDisplay();
}

function startGameRun() {
  // Полный рестарт параметров уровня
  base.hp = 100;
  restartLikesAccum = 0;
  gameState = 'running';
  // обновим UI-кнопки, если функция уже объявлена
  if (typeof updateUIButtons === 'function') updateUIButtons();
}

function addRestartLikes(delta) {
  const add = Math.max(0, Number(delta) || 0);
  if (add <= 0) return;
  restartLikesAccum += add;
  if (restartLikesAccum >= RESTART_LIKES_TARGET && gameState === 'waitingRestart') {
    startGameRun();
  }
}

// Для удобства — изменить порог из консоли
window.setRestartTarget = function(n) {
  RESTART_LIKES_TARGET = Math.max(1, Number(n) || RESTART_LIKES_TARGET);
}

function gameLoop() {
  ctx.save();
  ctx.setTransform(1, 0, 0, 1, 0, 0); // reset transform
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  // Масштабируем всё содержимое:
  const scale = Math.min(canvas.width / 640, canvas.height / 480);
  ctx.scale(scale, scale);

  ctx.drawImage(bgImage, 0, 0, 640, 480);

  if (showTowerZones) {
    for (const [x1, y1, x2, y2] of ALLOWED_TOWER_ZONES) {
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 2;
      ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
    }
  }

  if (gameState === 'running') {
    // --- SPAWN GOLEM IF NEEDED ---
    checkGolemSpawn();

    // Spawn обычных врагов
    // Спавним обычных мобов с учётом масштабирования плотности
    if (Math.random() < enemySpawnRate * ENEMY_DENSITY_SCALE) enemies.push(new Enemy());

    // Update
    for (const t of towers) t.update();
    for (const e of enemies) e.update();
    for (const b of bullets) b.update();
  }

  // Draw
  drawBase();
  // Разбиваем башни на дальние (за дорогой) и ближние (перед дорогой)
  const backTowers = [];
  const frontTowers = [];
  for (const t of towers) {
    const gy = getTowerGroundY(t);
    const cy = getClosestPathY(t.x, gy);
    if (cy == null || gy <= cy + FRONT_Y_EPS) backTowers.push(t); else frontTowers.push(t);
  }
  // 1) Дальние башни под мобами
  for (const t of backTowers) t.draw();
  // 2) Враги
  for (const e of enemies) if (!(e instanceof GolemEnemy)) e.draw();
  for (const e of enemies) if (e instanceof GolemEnemy) e.draw();
  // 3) Ближние башни поверх мобов
  for (const t of frontTowers) t.draw();
  // 4) Пули поверх всего
  for (const b of bullets) b.draw();

  // Remove dead
  if (gameState === 'running') {
    for (let i = enemies.length - 1; i >= 0; i--) {
      if (enemies[i].dead) enemies.splice(i, 1);
    }
    for (let i = bullets.length - 1; i >= 0; i--) {
      if (bullets[i].dead) bullets.splice(i, 1);
    }
    for (let i = towers.length - 1; i >= 0; i--) {
      if (towers[i].dead) {
        enemySpawnRate = Math.max(0, enemySpawnRate - 0.0015); // уменьшили шаг уменьшения при удалении башни
        updateSpawnRateDisplay();
        towers.splice(i, 1);
      }
    }
  }

  ctx.restore();

  // Переход в режим ожидания при смерти базы (или мгновенный рестарт, если лайк-режим отключён)
  if (gameState === 'running' && base.hp <= 0) {
    if (USE_LIKES_RESTART) {
      gameState = 'waitingRestart';
      softResetToWaiting();
      if (typeof updateUIButtons === 'function') updateUIButtons();
    } else {
      // Чистим сцену и сразу стартуем новый забег
      softResetToWaiting();
      startGameRun();
    }
  }

  // Оверлей ожидания (показывается только если включён лайк-режим и разрешён показ оверлея)
  if (gameState === 'waitingRestart' && USE_LIKES_RESTART && SHOW_RESTART_OVERLAY) {
    drawGameOverOverlay();
  }

  requestAnimationFrame(gameLoop);
}

function checkGolemSpawn() {
  if (towers.length >= 5 && !enemies.some(e => e instanceof GolemEnemy)) {
    enemies.push(new GolemEnemy());
    playGolemSpawnSound();
  }
}

function updateSpawnRateDisplay() {
  document.getElementById('spawnRateDisplay').textContent = enemySpawnRate.toFixed(3);
  document.getElementById('spawnRateCorner').textContent = `rate: ${enemySpawnRate.toFixed(3)}`;
}

function updateLeaderboardFromTowers() {
  // Собираем killCount и аватарки для всех AvatarTower
  const towersByUser = {};
  for (const t of towers) {
    if (t instanceof AvatarTower && t.killCount > 0) {
      // username = t.nickname или t.userId
      const username = t.nickname || t.userId || 'anon';
      towersByUser[username] = towersByUser[username] || {score: 0, avatarImg: t.avatarImg};
      towersByUser[username].score += t.killCount;
    }
  }
  // Обновляем leaderboard
  for (const [username, data] of Object.entries(towersByUser)) {
    leaderboard.update(username, data.avatarImg, data.score);
  }
}

function playSpawnTowerSound() {
  const audio = document.getElementById('spawnTowerSound');
  if (audio) {
    audio.volume = SPAWN_TOWER_VOL;
    audio.currentTime = 0;
    audio.play();
  }
}

function playGolemSpawnSound() {
  const audio = document.getElementById('golemSpawnSound');
  if (!audio) return;
  try {
    audio.volume = GOLEM_SPAWN_VOL;
    audio.currentTime = 0;
    audio.play();
  } catch (e) {
    // Игнорируем ошибки автоплея
  }
}

// Рык голема при спавне
function playGolemSpawnSound() {
  const audio = document.getElementById('golemSpawnSound');
  if (audio) {
    audio.volume = GOLEM_SPAWN_VOL;
    audio.currentTime = 0;
    audio.play();
  }
}

// --- ЗВУК ВЫСТРЕЛА ОБЫЧНОЙ БАШНИ (с троттлингом) ---
const BASIC_SHOT_SOUND_MIN_INTERVAL_MS = 140; // минимальный интервал между звуками
let lastBasicShotSoundTs = 0;
function playBasicTowerShotSound() {
  const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
  if (now - lastBasicShotSoundTs < BASIC_SHOT_SOUND_MIN_INTERVAL_MS) return; // слишком часто
  const audio = document.getElementById('basicTowerShotSound');
  if (!audio) return;
  try {
    audio.volume = BASIC_SHOT_VOL;
    audio.currentTime = 0;
    audio.play();
    lastBasicShotSoundTs = now;
  } catch (e) {
    // Игнорируем ошибки воспроизведения (например, политика автоплея)
  }
}

canvas.addEventListener('click', (e) => {
  if (gameState !== 'running') return; // блокируем клик-спавн до старта
  const rect = canvas.getBoundingClientRect();
  const rawX = e.clientX - rect.left;
  const rawY = e.clientY - rect.top;
  const scale = Math.min(canvas.width / 640, canvas.height / 480);
  const x = rawX / scale;
  const y = rawY / scale;
  let spawn = { x, y };
  if (isNearPath(x, y)) {
    // Если кликнули слишком близко к дороге — подберём безопасную позицию в разрешённых зонах
    spawn = findValidSpawnPos();
    console.warn('[SPAWN] Клик рядом с дорогой — смещаем башню в безопасную позицию', spawn);
  }
  towers.push(new Tower(spawn.x, spawn.y));
  playSpawnTowerSound();
  enemySpawnRate = Math.min(enemySpawnRate + 0.0015, 1); // немного пониженный прирост при добавлении башни
  updateSpawnRateDisplay();
});

document.getElementById('spawnPlus').onclick = () => {
  enemySpawnRate = Math.min(enemySpawnRate + 0.003, 1); // меньший шаг ручного увеличения
  updateSpawnRateDisplay();
};
updateSpawnRateDisplay();

const tiktokSocket = new WebSocket('ws://localhost:8080');
tiktokSocket.addEventListener('open', () => {
  console.log('[TikTok WS] Соединение установлено');
});
tiktokSocket.addEventListener('error', (err) => {
  console.log('[TikTok WS] Ошибка соединения', err);
});
let origTikTokMsgHandler = tiktokSocket.onmessage;
tiktokSocket.onmessage = function(event) {
  try {
    const data = JSON.parse(event.data);
    if (data.type === 'newTower') {
      if (gameState !== 'running') return; // не спавним до старта
      const pos = randomTowerPositionInAllowedZones();
      if (data.avatar) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = data.avatar;
        img.onload = () => {
          towers.push(new AvatarTower(pos.x, pos.y, img, data.nickname, data.userId));
          playSpawnTowerSound();
          enemySpawnRate = Math.min(enemySpawnRate + 0.0015, 1); // при успешной загрузке аватара
          updateSpawnRateDisplay();
        };
        img.onerror = () => {
          towers.push(new Tower(pos.x, pos.y));
          playSpawnTowerSound();
          enemySpawnRate = Math.min(enemySpawnRate + 0.0015, 1); // при ошибке аватара
          updateSpawnRateDisplay();
        };
      } else {
        towers.push(new Tower(pos.x, pos.y));
        playSpawnTowerSound();
        enemySpawnRate = Math.min(enemySpawnRate + 0.0015, 1);
        updateSpawnRateDisplay();
      }
    } else if (data.type === 'newGiftTower') {
      if (gameState !== 'running') return; // не спавним до старта
      const pos = randomTowerPositionInAllowedZones();
      const lvl = Number(data.level || 1);
      console.log('[WS] newGiftTower', {pos, lvl, hasAvatar: !!data.avatar, nickname: data.nickname, userId: data.userId});
      if (data.avatar) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.src = data.avatar;
        img.onload = () => {
          console.log('[WS] avatar loaded for gift tower');
          towers.push(new GiftAvatarTower(pos.x, pos.y, img, data.nickname, data.userId, lvl));
          playSpawnTowerSound();
          enemySpawnRate = Math.min(enemySpawnRate + 0.0015, 1); // подарочная башня с аватаром
          updateSpawnRateDisplay();
        };
        img.onerror = () => {
          console.warn('[WS] avatar failed to load, spawning without avatar');
          towers.push(new GiftAvatarTower(pos.x, pos.y, null, data.nickname, data.userId, lvl));
          playSpawnTowerSound();
          enemySpawnRate = Math.min(enemySpawnRate + 0.0015, 1); // подарочная башня без аватара (ошибка)
          updateSpawnRateDisplay();
        };
      } else {
        console.log('[WS] spawning gift tower without avatar');
        towers.push(new GiftAvatarTower(pos.x, pos.y, null, data.nickname, data.userId, lvl));
        playSpawnTowerSound();
        enemySpawnRate = Math.min(enemySpawnRate + 0.0015, 1);
        updateSpawnRateDisplay();
      }
    } else if (data.type === 'extLog') {
        // Выводим логи внешнего WS в консоль браузера
        if (data.level === 'raw') {
          console.log('[EXT][RAW]', data.message);
        } else {
          console.log('[EXT][EVENT]', data.eventType, data.payload);
          // Накопление лайков для рестарта: считаем дельту по каждому пользователю
          if (data.eventType === 'LIKE' && data.payload && data.payload.user) {
            const user = String(data.payload.user);
            const likesVal = Number(data.payload.likes || 0);
            const prev = lastSeenLikesByUser[user] || 0;
            // если сервер прислал дельту — prev обновим суммой; если прислал кумулятив — возьмём приращение
            const delta = Math.max(0, likesVal - prev);
            // Heuristic: если likesVal выглядит как дельта (малое и prev=0), добавим напрямую и увеличим prev на likesVal
            if (likesVal > 0 && delta === likesVal) {
              lastSeenLikesByUser[user] = prev + likesVal;
              if (gameState === 'waitingRestart') addRestartLikes(likesVal);
            } else if (delta > 0) {
              lastSeenLikesByUser[user] = likesVal;
              if (gameState === 'waitingRestart') addRestartLikes(delta);
            }
          }
        }
      } else if (origTikTokMsgHandler) {
        origTikTokMsgHandler.call(tiktokSocket, event);
      }
    } catch (e) {
      console.log('[TikTok WS] Ошибка обработки сообщения:', e);
    }
  };

bgImage.onload = () => {
  gameLoop();
};
</script>
</body>
</html>